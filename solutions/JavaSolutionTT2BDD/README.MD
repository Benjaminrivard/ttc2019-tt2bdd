# Groupe 1 : JavaSolutionTT2BDD 

[![Generic badge](https://img.shields.io/badge/Correctness-OK-green.svg)](https://github.com/Benjaminrivard/ttc2019-tt2bdd/tree/master/solutions/JavaSolutionTT2BDD)
[![Generic badge](https://img.shields.io/badge/Conciseness-OK-green.svg)](https://github.com/Benjaminrivard/ttc2019-tt2bdd/tree/master/solutions/JavaSolutionTT2BDD)
[![Generic badge](https://img.shields.io/badge/Readability-OK-green.svg)](https://github.com/Benjaminrivard/ttc2019-tt2bdd/tree/master/solutions/JavaSolutionTT2BDD)
[![Generic badge](https://img.shields.io/badge/Efficiency-GOOD-orange.svg)](https://github.com/Benjaminrivard/ttc2019-tt2bdd/tree/master/solutions/JavaSolutionTT2BDD)

# Pr√©-requis :
* 64-bit operating system
* Python 3.3 or higher
* R ( d√©pendances √† installer avec le script reporting/install.R)

# Instructions pour l'installation
1. Ins√©rer la solution suivante dans le dossier solutions du framework ttc2019-tt2bdd
2. Inscrire l'entr√©e "JavaSolutionTT2BDD" dans le tableau "Tools" du fichier config/config.json
3. √âditer les Models √† g√©n√©rer et √©ventuellement le nombre de cycle de test ainsi que le timeout
4. Supprimer le fichier output/output.csv avant de lancer le framework
5. lancer le framework de test √† l'aide de la commande suivante depuis la racine du projet (/ttc2019-tt2bdd):
    > ./scripts/run.py
6. (Optionel) Utiliser le validator.jar pour valider les r√©sultats : 
    >
    > java -jar models/validator.jar ttModel bddModel
    > - java -jar models/validator.jar models/GeneratedI8O2Seed68.ttmodel solutions/JavaSolutionTT2BDD/I8O2Seed68.bddmodel
    > - java -jar models/validator.jar models/GeneratedI8O2Seed68.ttmodel solutions/JavaSolutionTT2BDD/GeneratedI8O2Seed68.ttmodel.bddmodel

# Ce qui a √©t√© fait et marche / ce qui n‚Äôa pas √©t√© fait et/ou ne marche pas
Une solution en Kotlin a √©t√© d√©velopp√©e pour transformer les truth tables re√ßues en entr√©e en binary decision diagram.
La solution est capable de : 
 * prendre en entr√©e un model xmi de type Truthtable comme g√©n√©r√© par le generator.jar du projet (model/generator.jar)
 * lire ce mod√®le et lancer une solution
 * √©crire un abre de d√©cision binaire correspondant (valid√© "All Ok" par le validator.jar)
 * mesurer son temps d'ex√©cution et de transmettre au benchmark les valeurs mesur√©es

La solution n'est pas capable de :
 * rivaliser avec les meilleures solutions du tournoi en terme de performances brutes
 * transformer d'autres types de modeles
 * optimiser l'arbre (cela incluerait des potentielles modifications de l'arbre produit et donc sa non-validation)

# Les choix
#### Rappel: S'il y a eu choix,  il y avait au moins deux manieres de faire. D√©crire les manieres, leurs avantages et inconvenients qui ont permis de choisir

Initiallement, nous √©tions partis sur une solution en Java. Nous n'√©tions pas suffisament confiants pour commencer sur un autre langage type Scala par example. 
N√©anmoins apr√®s le cours sur Android que nous avons eu durant le S1-A3 o√π nous avons beaucoup utilis√© Kotlin, nous nous sommes aper√ßus que ce langage pouvait nous permettre
de simplifier et de rendre plus concis et √©l√©gant le code de notre solution. 

Nous avons donc effectu√© une transformation de notre solution de Java √† Kotlin. Le processus a √©t√© tr√®s rapide gr√¢ce √† l'interoperabilit√© qu'il existe entre les deux langages. 

La solution a √©t√© √©crit en Kotlin car :
* Ce langage est conforme au cahier des charges du projet (JVM-based)
* Il permet de r√©aliser des instructions complexes de fa√ßon tr√®s lisible et √©l√©gante ( avec des concepts √† la crois√©e entre Object-Oriented et langage fonctionnel)
* Il est possible d'appeler des fonctions Java depuis Kotlin, et donc d'utiliser l'API EMF fournit avec la solution (utilisation du metamodel TT et BDD)
* Avantages de Kotlin (nativement) sur java : 
    * Singleton
    * Lambda & inline functions
    * null-safety
    * Notions de var & val (variables et constantes)
    * Inf√©rence triviale de type 
    * ... 

# Ce que vous referiez diff√©remment
* Moins de bidouillage au d√©but du projet pour faire tourner sur une machine Linux des solutions dont on pouvait se passer
* Ne pas s'obstiner √† vouloir faire tourner une solution si l'on y arrive pas (NMF solution en .net core qui ne fonctionne toujours pas sur nos poste √† l'heure actuelle)
* Demander plus rapidement de l'aide en cas de probl√®mes sur l'utilisation du framework
* Se focaliser sur l'optimisation du model de truth table en entr√©e

# Ce qui pourrait etre ajoute
* Notre solution pourrait √™tre plus modulaire. A l'heure actuelle, il existe un seul service qui r√©sout le probl√®me de la transformation de TT √† BDD. On pourrait imaginer une solution qui pointe de fa√ßon plus autonome sur le service comp√©tent pour effectuer la transformation et donc rendre notre solution utilisable pour d'autres mod√®les.
* Des optimisations suppl√©mentaires dans le code (m√™me si elles sont difficiles √† identifier en l'√©tat).
* Une analyse de la complexit√© de notre transformation pour comprendre o√π sont les points critiques et donc am√©liorer les performances.


# Points forts et points faibles de votre projet
## Correctness ‚úî
Tous les models sont valid√©s par le validateur.
## Conciseness ‚úî
Le code de la solution est concis. La solution en elle-m√™me est cod√©e sur 200 lignes de code (de fa√ßon a√©r√©e et avec beaucoup de commentaires).
## Readability ‚úî
Le code est bien document√© et est lisible.
## Efficiency ü§∑
Le r√©sultat sont plut√¥t bon par rapport aux solutions de base du framework.
Les r√©sultats ne sont cependant pas √† la hauteur des gagnants du concours pour le prix des performances (Fulib Solution).
Nous √©mettons plusieurs hypoth√®ses : 
* La solution Fulib utilise des matrices (les fulibTables) en compl√©ment de L'API EMF. Ces derni√®res sont selon le cr√©ateur plus efficace
    > ### Extrait du papier de Albert Zuendorf sur sa solution :
    > I am not sure, how the difference in runtime may be explained. First of all, an `ArrayList<ArrayList<Object>>`
     is a pretty compact and fast model. If we count each ArrayList as one object, the case with 15 + 5 ports has
     2^15 i.e. about 32 000 rows. Within the original EMF Truth Table Model, there are extra objects for each cell.
     These are additional 20 cell objects per row resulting in 640 000 cell objects. Thus, this may account for some
     factor of 20 in memory and accordingly in runtime usage.
     Still, it seems that the EMFSolutionATL is not in the
     same runtime complexity class as the Fulib solution.
* La solution n'est pas tr√®s flexible et n'est pas adapt√© au cas limite 
    > ### Extrait du papier de Albert Zuendorf sur sa solution :
    > To be honest, the current Fulib
    solution works only for regular input (no don‚Äôt cares, always the same order of cells)  
## R√©sultats du benchmark pour quelques mod√®les simples:
![Resultat-du-benchmark-simple](benchmark/results/results-GroupBy-Tool-Time.png)

## R√©sultats du benchmark pour tous les mod√®les : 
###### (La solution EMFSolutionATL n'est plus dans le graphe car elle ne r√©sout pas les transformation de model plus complexes comme la table √† 15 Input et 5 Output)
![Resultat-du-benchmark-medium](benchmark/results/results-GroupBy-Tool-Time-big.png)

Nous sommes donc au coude √† coude avec la solution EMFSolutionYAMTL, qui a √©t√© √©lue "Most Optimal Solution" du concours.

# Backlog du projet
## 11/10/19 (4h)
- lecture des articles li√©s aux diff√©rentes solutions
- lecture du sujet du tournoi
- t√©l√©chargement du projet benchmark et installation sur windows infructueuse
- t√©l√©chargement, installation de l'OS et des d√©pendances projets sur une VM Linux
## 14/10/2019 (4h)
- installation du projet sur la VM : r√©sultat non satisfaisant, trop lent
## 15/10/2019 (4h)
- installation projet sur windows
- adaptation des commandes de chaques solutions
- premier run du projet en entier
- fix des solutions Rsync et NMF
## 25/10/2019 (4h)
- tentative de fix de la visualisation des r√©sultats : benchmark op√©rationnel
- lecture de la doc eclipse ATL
## 28/10/2019 (4h)
- lancement de plusieurs benchmarks
- cr√©ation du projet Java
- lecture de la doc gradle & Kotlin
## 29/10/2019 (4h)
- d√©but de l'impl√©mentation de la solution na√Øve fournie dans l'outline 2.3 du papier
- transformation des inputs ports tt en bdd
- transformation des outputs ports tt en bdd
## 07/11/2019 (hors cr√©neau √©cole) (1h)
- transformation des row en leafs et des cell en assignements
## 13/11/2019(4h)
- r√©cup√©rer un port qui est utilis√© dans toutes les rows
- cr√©ation des cells qui pointent vers un output port en assignment
## 19/11/2019(4h)
- transformation du projet java en projet kotlin (nous avons eu un cours sur ce sujet et nous pensions √™tre plus en confiance dessus)
- utilisation du framework pour tester la solution
- premiers graphs de benchmark encourageant
## 22/11/2019 (4h)
- Benchmarks de plusieurs solutions
- modification du fichier run.py afin de rendre le nom des solutions plus concis ( et donc plus lisible dans le graph)
- travail sur l'optimisation de l'arbre ( essais manuels de cas de transformation optimis√©e et comparaison des r√©sultats obtenus avec ceux de la solution)
- Modification du repo git et nettoyage des branches
- branche linux pour run le projet
- validation de tous les r√©sultats produits par la solution (all ok sur tous les sch√©mas)
## 26/11/2019 (4h)
- Documentation finale du projet
- Benchmarks de plusieurs solutions avec le graph rendu plus lisible
