aspect OBDT {

  syn nta BDT TruthTable.OBDT() {

    BDT bdt = emptyBDT();

    // select an input port
    // Idea:
    // 1. pick port order
    PortOrder portOrder = getPortOrder();
    // 1b. create tree for first port in TT
    BDT_Subtree firstSubtree = new BDT_Subtree();
    firstSubtree.setPort(bdt.bdtInputPort(portOrder.getPortList().get(0)));
    bdt.setTree(firstSubtree);
    // 2. iterate over rows, create or get inner nodes until last port which will be a leaf
    Port leafPort = portOrder.leafPort();
    for (Row row : getRowList()) {
      BDT_Subtree current = firstSubtree;
      Boolean value = row.valueFor(firstSubtree.getPort().getTruthTableInputPort());
      for (InputPort port : portOrder.subTreePortList()) {
        if (value!=null) {
          current = current.getOrCreateSubtree(port, value);
        } else {
          current.getOrCreateSubtree(port, true);
          current = current.getOrCreateSubtree(port, false);
        }
        value = row.valueFor(port);
      }
      // create leaf node
      current.createLeafNode(leafPort, row);
    }

    return bdt;
  }

  //--- subTreePortList ---
  syn List<InputPort> PortOrder.subTreePortList() = getPortList().subList(1, getPortList().size());

  //--- leafPort ---
  syn InputPort PortOrder.leafPort() = getPortList().get(getPortList().size() - 1);

  //--- getOrCreateSubtree ---
  BDT_Subtree BDT_Subtree.getOrCreateSubtree(InputPort port, Boolean value) {
    BDT_Subtree result = null;
    if (value == null || value) {
      if (getTreeForOne() != null) {
        result = getTreeForOne().asSubtree();
      } else {
        result = new BDT_Subtree();
        result.setPort(bdt().bdtInputPort(port));
        setTreeForOne(result);
      }
    }
    if (value == null || !value) {
      if (getTreeForZero() != null) {
        result = getTreeForZero().asSubtree();
      } else {
        result = new BDT_Subtree();
        result.setPort(bdt().bdtInputPort(port));
        setTreeForZero(result);
      }
    }
    return result;
  }

  //--- createLeafNode ---
  void BDT_Subtree.createLeafNode(Port lastPort, Row row) {
    // assumption: treeForOne/Zero is always null at this point, so no need to check first
    BDT_Leaf leaf = new BDT_Leaf();
    for (Cell cell : row.getCellList()) {
      if (!cell.getPort().isInput()) {
        // add to list of assignments
        BDT_Assignment assignment = new BDT_Assignment();
        assignment.setPort(bdt().bdtOutputPort(cell.getPort()));
        assignment.setValue(cell.getValue());
        leaf.addAssignment(assignment);
      }
    }
    Boolean value = row.valueFor(lastPort);
    if (value == null){
      setTreeForOne(leaf);
      BDT_Leaf leaf2 = new BDT_Leaf();
      for (Cell cell : row.getCellList()) {
        if (!cell.getPort().isInput()) {
          // add to list of assignments
          BDT_Assignment assignment = new BDT_Assignment();
          assignment.setPort(bdt().bdtOutputPort(cell.getPort()));
          assignment.setValue(cell.getValue());
          leaf2.addAssignment(assignment);
        }
      }
      setTreeForZero(leaf2);
    } else if (value) {
      setTreeForOne(leaf);
    } else {
      setTreeForZero(leaf);
    }
  }

  /**
   * Return a list of rows, for which the given port has the given value.
   * Preformance-Note: This should be done using an iterator, and not manifesting it as a new list.
   */
  syn List<Row> TruthTable.getRowsFor(Port port, boolean value) {
    List<Row> result = new ArrayList<>();
    for (Row row : getRowList()) {
      if (row.valueFor(port) == value) {
        result.add(row);
      }
    }
    return result;
  }

}
