aspect OBDT {

  public BDT TruthTable.OBDT() {
    BDT bdt = new BDT();

    //  Each TruthTable object should correspond to a BDT object, with the same name and equivalent Ports.
    bdt.setName(getName());

    //  Each InputPort and OutputPort should be mapped to an object of the BDT
    for (Port port: getPortList()) {
      bdt.addPort(port);
    }

    // select an input port
    // Idea:
    // 1. pick port order
    PortOrder portOrder = getPortOrder();
    // 1b. create tree for first port in TT
    Subtree firstSubtree = new Subtree();
    firstSubtree.setPort(portOrder.getPortList().get(0));
    bdt.setTree(firstSubtree);
    // 2. iterate over rows, create or get inner nodes until last port which will be a leaf
    Port leafPort = portOrder.leafPort();
    for (Row row : getRowList()) {
      Subtree current = firstSubtree;
      Boolean value = row.valueFor(firstSubtree.getPort());
      for (InputPort port : portOrder.subTreePortList()) {
        if (value!=null) {
          current = current.getOrCreateSubtree(port, value);
        } else {
          current.getOrCreateSubtree(port, true);
          current = current.getOrCreateSubtree(port, false);
        }
        value = row.valueFor(port);
      }
      // create leaf node
      current.createLeafNode(leafPort, row);
    }

    return bdt;
  }

  //--- subTreePortList ---
  syn List<InputPort> PortOrder.subTreePortList() = getPortList().subList(1, getPortList().size());

  //--- leafPort ---
  syn InputPort PortOrder.leafPort() = getPortList().get(getPortList().size() - 1);

  //--- getOrCreateSubtree ---
  Subtree Subtree.getOrCreateSubtree(InputPort port, Boolean value) {
    Subtree result = null;
    if (value == null || value) {
      if (getTreeForOne() != null) {
        result = getTreeForOne().asSubtree();
      } else {
        result = new Subtree();
        result.setPort(port);
        setTreeForOne(result);
      }
    }
    if (value == null || !value) {
      if (getTreeForZero() != null) {
        result = getTreeForZero().asSubtree();
      } else {
        result = new Subtree();
        result.setPort(port);
        setTreeForZero(result);
      }
    }
    return result;
  }

  //--- createLeafNode ---
  void Subtree.createLeafNode(Port lastPort, Row row) {
    // assumption: treeForOne/Zero is always null at this point, so no need to check first
    Leaf leaf = new Leaf();
    for (Cell cell : row.getCellList()) {
      if (!cell.getPort().isInput()) {
        // add to list of assignments
        Assignment assignment = new Assignment();
        assignment.setPort(cell.getPort().asOutput());
        assignment.setValue(cell.getValue());
        leaf.addAssignment(assignment);
      }
    }
    Boolean value = row.valueFor(lastPort);
    if (value == null){
      setTreeForOne(leaf);
      Leaf leaf2 = new Leaf();
      for (Cell cell : row.getCellList()) {
        if (!cell.getPort().isInput()) {
          // add to list of assignments
          Assignment assignment = new Assignment();
          assignment.setPort(cell.getPort().asOutput());
          assignment.setValue(cell.getValue());
          leaf2.addAssignment(assignment);
        }
      }
      setTreeForZero(leaf2);
    } else if (value) {
      setTreeForOne(leaf);
    } else {
      setTreeForZero(leaf);
    }
  }

  /**
   * Return a list of rows, for which the given port has the given value.
   * Preformance-Note: This should be done using an iterator, and not manifesting it as a new list.
   */
  syn List<Row> TruthTable.getRowsFor(Port port, boolean value) {
    List<Row> result = new ArrayList<>();
    for (Row row : getRowList()) {
      if (row.valueFor(port) == value) {
        result.add(row);
      }
    }
    return result;
  }

  public Tree TruthTable.subTree(List<InputPort> remainingPorts) {
    return null;
  }
}
