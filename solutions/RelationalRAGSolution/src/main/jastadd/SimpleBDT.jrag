aspect SimpleBDT {

  public BDT TruthTable.simpleBDT() {
    BDT bdt = new BDT();

    //  Each TruthTable object should correspond to a BDT object, with the same name and equivalent Ports.
    bdt.setName(getName());

    //  Each InputPort and OutputPort should be mapped to an object of the BDT
    for (Port port: getPortList()) {
      bdt.addPort(port);
    }

    // select an input port
    // Idea:
    // 1. pick port order
    PortOrder portOrder = getPortOrder();
    // 1b. create tree for first port in TT
    Subtree firstSubtree = new Subtree();
    firstSubtree.setPort(portOrder.getPortList().get(0));
    bdt.setTree(firstSubtree);
    // 2. iterate over rows, create or get inner nodes until last port which will be a leaf
    Port leafPort = portOrder.leafPort();
    for (Row row : getRowList()) {
      row.printDebug();
      Subtree current = firstSubtree;
      boolean value = row.valueFor(firstSubtree.getPort());
      for (InputPort port : portOrder.subTreePortList()) {
        current = current.getOrCreateSubtree(port, value);
        value = row.valueFor(port);
      }
      // create leaf node
      current.createLeafNode(leafPort, row);
    }

    return bdt;
  }

  void Row.printDebug() {
    StringBuilder b = new StringBuilder("row ");
    boolean first = true;
    for (Cell cell : getCellList()) {
      if (first) {
        first = false;
      } else {
        b.append(" ");
      }
      b.append(cell.getPort().getName())
        .append(":")
        .append(cell.getValue() ? 1 : 0);
    }
    logger.info(b.toString());
  }

  //--- subTreePortList ---
  syn List<InputPort> PortOrder.subTreePortList() = getPortList().subList(1, getPortList().size());

  //--- leafPort ---
  syn InputPort PortOrder.leafPort() = getPortList().get(getPortList().size() - 1);

  //--- getOrCreateSubtree ---
  Subtree Subtree.getOrCreateSubtree(InputPort port, boolean value) {
    Subtree result;
    Tree tree = value ? getTreeForOne() : getTreeForZero();
    if (tree == null) {
      logger.debug("new subtree {} -{}-> {}", getPort().getName(), value ? 1 : 0, port.getName());
      Subtree subTree = new Subtree();
      subTree.setPort(port);
      if (value) {
        setTreeForOne(subTree);
      } else {
        setTreeForZero(subTree);
      }
      result = subTree;
    } else {
      result = tree.asSubtree();
    }
    return result;
  }

  //--- createLeafNode ---
  void Subtree.createLeafNode(Port lastPort, Row row) {
    // assumption: treeForOne/Zero is always null at this point, so no need to check first
    logger.debug("new leaf {} -{}-> leaf", getPort().getName(), row.valueFor(lastPort) ? 1 : 0);
    Leaf leaf = new Leaf();
    for (Cell cell : row.getCellList()) {
      if (!cell.getPort().isInput()) {
        // add to list of assignments
        Assignment assignment = new Assignment();
        assignment.setPort(cell.getPort().asOutput());
        assignment.setValue(cell.getValue());
        leaf.addAssignment(assignment);
      }
    }
    if (row.valueFor(lastPort)) {
      setTreeForOne(leaf);
    } else {
      setTreeForZero(leaf);
    }
  }

  /**
   * Return a list of rows, for which the given port has the given value.
   * Preformance-Note: This should be done using an iterator, and not manifesting it as a new list.
   */
  syn List<Row> TruthTable.getRowsFor(Port port, boolean value) {
    List<Row> result = new ArrayList<>();
    for (Row row : getRowList()) {
      if (row.valueFor(port) == value) {
        result.add(row);
      }
    }
    return result;
  }

  // Eval probably in extra aspect
  syn boolean Row.valueFor(Port port) {
    for (Cell cell : getCellList()) {
      if (cell.getPort().equals(port)) {
        return cell.getValue();
      }
    }
    return false;
  }

  syn PortOrder TruthTable.getPortOrder() {
    // a port order defines the order, in which the input ports are evaluated
    // for the simple case, this order is defined by the list in which the ports are defined
    PortOrder result = new PortOrder();
    for (Port port : getPortList()) {
      if (port.isInput()) {
        result.addPort(port.asInput());
      }
    }
    return result;
  }

  public Tree TruthTable.subTree(List<InputPort> remainingPorts) {
    return null;
  }
}
