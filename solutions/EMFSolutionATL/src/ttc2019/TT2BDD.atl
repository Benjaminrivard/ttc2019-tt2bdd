module TT2BDD;
create OUT:BDD from IN:TT;

rule TruthTable2BDD {
   from src : TT!TruthTable
   to dest : BDD!BDD
      (
         name <- src.name,
         ports <- src.ports,
         tree <- src.getTree().cell
      )
}

rule InputPort2InputPort {
   from src : TT!InputPort
   to dest : BDD!InputPort
      (
         name <- src.name
      )
}

rule OutputPort2OutputPort {
   from src : TT!OutputPort
   to dest : BDD!OutputPort
      (
         name <- src.name
      )
}

rule Row2Leaf {
   from src : TT!Row
   to dest : BDD!Leaf
      (
         assignments <- src.cells->select(c | c.port.oclIsKindOf(TT!OutputPort))
      )
}

rule Cell2Assignment {
   from src: TT!Cell (src.port.oclIsKindOf(TT!OutputPort))
   to dest : BDD!Assignment
      (
         value <- src.value,
         port <- src.port
      )
}

rule Cell2Subtree {
   from src: TT!Cell (not src.getNode().oclIsUndefined())
   using {
      node : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =
         src.getNode();
   }
   to dest : BDD!Subtree
      (
         port <- src.port,
         treeForZero <-
            if node.zeroSubtree.oclIsKindOf(TT!Row) then
               node.zeroSubtree
            else
               node.zeroSubtree.cell
            endif,
         treeForOne <-
            if node.oneSubtree.oclIsKindOf(TT!Row) then
               node.oneSubtree
            else
               node.oneSubtree.cell
            endif
      )
}

---------------------------------------------------------------------------------------------------
-- Partitionner une partie de la table de vérité.
--
-- Ce helper effectue un travail préparatoire à la création d'un arbre binaire.
-- En prenant une sous-ensemble des lignes d'une table de vérité et un port de référence, il 
-- retourne deux sous-ensembles de lignes : celles pour lesquelles le port vaut faux
-- et celles pour lesquelles le port vaut vrai.
--
-- Entrées :
--    rows : l'ensemble des lignes à traiter
--    port : le port qui doit servir de référence au partitionnement
--
-- Sorties :
--    un tuple contenant :
--       zeroPart : l'ensemble des lignes pour lesquelles ce port vaut zéro (faux)
--       onePart  : l'ensemble des lignes pour lesquelles ce port vaut un (vrai)
--
-- Préconditions :
--
--    Le port à utiliser doit être un port d'entrée :
--
--       port.oclIsKindOf(TT!InputPort))
--
--    Sa valeur est définie dans toutes les lignes
--
--         rows->forAll(r |
--            r.cells->collect(c | c.port)
--                   ->includes(port)
--         )
---------------------------------------------------------------------------------------------------
helper def:
   getPartition(rows : Sequence(TT!Row), port : TT!Port)
      : TupleType( zeroPart : Sequence(TT!Row) , onePart : Sequence(TT!Row) ) =
      
      -- Sélectionner les lignes pour lesquelles ce port vaut faux
      let _zeroPart : Sequence(TT!Row) =
         rows->select(r |
            r.cells->exists(c |
               c.port = port and c.value = false
            )
         ) in
         
      -- Sélectionner les lignes pour lesquelles ce port vaut vrai
      let _onePart : Sequence(TT!Row) =
         rows->select(r |
            r.cells->exists(c |
               c.port = port and c.value = true
            )
         ) in

      -- Construire le tuple résultat
      Tuple{
         zeroPart = _zeroPart,
         onePart = _onePart
      };

---------------------------------------------------------------------------------------------------
-- Build a tree structure from a sequence of rows.
--
-- This helper builds a tree from tuples. Among the sequence of usable inputs, it selects a
-- port where the value is defined in all lines.
--
-- The helper getPartition is invoked to obtain two row subsequences that correspond to the
-- possible states from the selected port.
--
-- The tree is built recursively, with the base case leaving the row sequence as a single row.
--
-- Inputs:
--    rows        : the sequence of rows to be processed
--    usablePorts : the sequence of ports to be considered to build the tree
--
-- Outputs:
--    a tuple contains:
--      cell        : a cell which acts as a reference and points to the current tree node
--      zeroSubtree : the subtree for the 0 value of the port
--      oneSubtree  : the subtree for the 1 value of the port
---------------------------------------------------------------------------------------------------
helper def:
   getTree(rows : Sequence(TT!Row), usablePorts : Sequence(TT!Port))
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      -- Parmi tous les ports utilisables, en choisir un dont la valeur est définie
      -- dans toutes les lignes
      let _port : TT!Port =
         usablePorts->any(p |
            rows->forAll(r |
               r.cells->collect(c | c.port)
                     ->includes(p)
            )
         ) in
      
      -- Sélectionner une cellule qui définit une valeur pour ce port
      let _cell : TT!Cell =
         rows->first().cells->any(c | c.port = _port) in
         
      -- Partitionner l'ensemble de lignes fourni
      let _part : TupleType( zeroPart : Sequence(TT!Row), onePart : Sequence(TT!Row) ) =
         thisModule.getPartition(rows, _port) in

      -- Définir le nouvel ensemble de ports utilisables pour les partitionnements ultérieurs
      let _updatedPorts : Sequence(TT!Port) =
         usablePorts->excluding(_port) in
            
      -- Construire le tuple résultat : une structure d'arbre est construite récursivement
      Tuple{
         cell = _cell,
         zeroSubtree =
            if _part.zeroPart->size() = 1 then
               _part.zeroPart->first()
            else
               thisModule.getTree(_part.zeroPart, _updatedPorts)
            endif,
         oneSubtree =
            if _part.onePart->size() = 1 then
               _part.onePart->first()
            else
               thisModule.getTree(_part.onePart, _updatedPorts)
            endif
      };

---------------------------------------------------------------------------------------------------
-- Obtenir l'arbre représentatif d'une table de vérité complète.
--
-- Ce helper construit une structure d'arbre en utilisant thisModule.getTree().
---------------------------------------------------------------------------------------------------
helper context TT!TruthTable def:
   getTree()
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =
      thisModule.getTree(self.rows, self.ports->select(p | p.oclIsKindOf(TT!InputPort)));
      
---------------------------------------------------------------------------------------------------
-- Search for a truth table cell within a tree
--
-- This helper explores recursively the subtrees until the cell is found or until
-- the entire tree has been searched without a match.
--
-- Inputs :
--    cell : the cell to be found
--    tree : the root node of the tree which should be searched
--
-- Outputs :
--    a node of the tree if found,
--    OclUndefined if unsuccessful
---------------------------------------------------------------------------------------------------
helper def:
   findCell(cell : TT!Cell, tree : TupleType( cell : TT!Cell, zeroSubtree : OclAny, oneSubtree : OclAny ))
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      if tree.cell = cell then
         tree
      else if tree.zeroSubtree.oclIsKindOf(TT!Row) then
         if tree.oneSubtree.oclIsKindOf(TT!Row) then
            -- Both subtrees are leaf nodes
            OclUndefined
         else
            -- Only the subtree 1 is not a leaf
            thisModule.findCell(cell,tree.oneSubtree)
         endif
      else
         let tryInZero : OclAny = thisModule.findCell(cell,tree.zeroSubtree) in
         if tree.oneSubtree.oclIsKindOf(TT!Row) then
            -- Only the subtree 0 is not a leaf
            tryInZero
         else if tryInZero.oclIsUndefined() then
            -- Both subtrees are non-leaves, but subtree 0 did not produce any results
            thisModule.findCell(cell,tree.oneSubtree)
         else
            -- Both subtrees are non-leaves, and subtree 0 has produced results
            tryInZero
         endif endif
      endif endif;

---------------------------------------------------------------------------------------------------
-- Obtenir, pour une cellule donnée d'une table de vérité, le noeud correspondant dans l'arbre
-- représentatif de cette table.
--
-- Ce helper utilise getTree et findCell.
---------------------------------------------------------------------------------------------------
helper context TT!Cell def:
   getNode() 
      : TupleType( cell : TT!Cell , zeroSubtree : OclAny , oneSubtree : OclAny ) =

      thisModule.findCell(self, self.owner.owner.getTree());
